use anyhow::{Error, Result, bail};
use std::path::{Path, PathBuf};
use std::fs;
use std::process::Command;
use log::{info, warn};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use regex::Regex;

/// Song information structure for CSV/JSON output
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SongInfo {
    pub video_title: String,
    pub video_url: String,
    pub song_title: String,
    pub artist: String,
    pub timestamp: Option<String>,
    pub downloaded: bool,
    pub match_confidence: f32,
}

/// Download songs from a CSV/JSON file generated by query-url
pub fn download_songs(csv_path: &Path, directory: &Path) -> Result<(), Error> {
    info!("Starting song download process");
    
    // Check if directory exists
    if !directory.exists() {
        bail!("Directory does not exist: {:?}", directory);
    }
    
    // Read the CSV/JSON file
    let file_content = fs::read_to_string(csv_path)?;
    let songs: Vec<SongInfo> = if csv_path.extension().unwrap_or_default() == "json" {
        serde_json::from_str(&file_content)?
    } else {
        // Assume CSV format
        parse_csv(&file_content)?
    };
    
    info!("Found {} songs in the input file", songs.len());
    
    // Group songs by video title
    let mut songs_by_video: HashMap<String, Vec<SongInfo>> = HashMap::new();
    for song in songs {
        songs_by_video
            .entry(song.video_title.clone())
            .or_insert_with(Vec::new)
            .push(song);
    }
    
    info!("Processing {} videos", songs_by_video.len());
    
    // Process each video
    for (video_title, songs) in songs_by_video {
        info!("Processing video: {}", video_title);
        
        // Create sanitized folder name
        let folder_name = sanitize_filename(&video_title);
        let video_folder = directory.join(&folder_name);
        
        // Check if folder exists, create if not
        let folder_existed = video_folder.exists();
        if !folder_existed {
            info!("Creating folder: {:?}", video_folder);
            fs::create_dir_all(&video_folder)?;
        } else {
            info!("Folder already exists: {:?}", video_folder);
        }
        
        // Filter songs that were marked for download 
        // Logic fix: if downloaded flag is false, it means we should download it
        // We also respect folder_existed - if folder already exists, we skip songs
        let songs_to_download: Vec<&SongInfo> = songs.iter()
            .filter(|song| !song.downloaded && (!folder_existed || song.match_confidence > 0.5))
            .collect();
        
        if songs_to_download.is_empty() {
            info!("No songs to download in this video");
            continue;
        }
        
        info!("Downloading {} songs for video: {}", songs_to_download.len(), video_title);
        
        // Download each song
        for song in songs_to_download {
            match download_song(song, &video_folder) {
                Ok(_) => info!("Successfully downloaded: {} - {}", song.artist, song.song_title),
                Err(e) => warn!("Failed to download song {} - {}: {}", song.artist, song.song_title, e),
            }
        }
        
        // Return to original directory for next video
        info!("Completed processing video: {}", video_title);
    }
    
    info!("Song download process completed");
    Ok(())
}

/// Download a single song using yt-dlp or spotdl
fn download_song(song: &SongInfo, output_folder: &Path) -> Result<(), Error> {
    let song_query = format!("{} - {}", song.artist, song.song_title);
    info!("Downloading song: {}", song_query);
    
    // Sanitize the song query to make it safe for command line
    let safe_query = sanitize_query(&song_query);
    
    // Check if song already exists in the folder
    let song_exists = check_if_song_exists(output_folder, &song.artist, &song.song_title)?;
    if song_exists {
        info!("Song already exists in folder, skipping: {}", song_query);
        return Ok(());
    }
    
    // Try to download using yt-dlp with YouTube Music
    info!("Attempting to download with yt-dlp: {}", safe_query);
    let result = download_with_ytdlp(&safe_query, output_folder);
    
    if result.is_err() {
        // Fallback to spotdl if yt-dlp fails
        warn!("yt-dlp failed for {}, trying spotdl", safe_query);
        match download_with_spotdl(&safe_query, output_folder) {
            Ok(_) => {
                info!("Successfully downloaded with spotdl: {}", safe_query);
            },
            Err(e) => {
                warn!("Both yt-dlp and spotdl failed for {}: {}", safe_query, e);
                return Err(e);
            }
        }
    } else {
        info!("Successfully downloaded with yt-dlp: {}", safe_query);
    }
    
    Ok(())
}

/// Sanitize a query for command line safety
fn sanitize_query(query: &str) -> String {
    // Replace special characters that could cause issues in command line
    let sanitized = query
        .replace("\"", "")
        .replace("'", "")
        .replace("(", "")
        .replace(")", "")
        .replace("[", "")
        .replace("]", "")
        .replace("&", "and")
        .replace("|", "-");
    
    sanitized
}

/// Check if a song already exists in the folder
fn check_if_song_exists(folder: &Path, artist: &str, title: &str) -> Result<bool, Error> {
    if !folder.exists() {
        return Ok(false);
    }
    
    // Get all mp3 files in the folder
    let entries = fs::read_dir(folder)?;
    
    for entry in entries {
        let entry = entry?;
        let path = entry.path();
        
        if path.is_file() && path.extension().map_or(false, |ext| ext == "mp3") {
            let filename = path.file_name().unwrap().to_string_lossy().to_lowercase();
            let artist_lower = artist.to_lowercase();
            let title_lower = title.to_lowercase();
            
            // Check if filename contains both artist and title
            if filename.contains(&artist_lower) && filename.contains(&title_lower) {
                return Ok(true);
            }
        }
    }
    
    Ok(false)
}

/// Download a song using yt-dlp
fn download_with_ytdlp(song_query: &str, output_folder: &Path) -> Result<(), Error> {
    let output_template = output_folder.join("%(title)s.%(ext)s").to_string_lossy().to_string();
    
    // Build yt-dlp command with YouTube Music search
    let status = Command::new("yt-dlp")
        .args([
            "--extract-audio",
            "--audio-format", "mp3",
            "--audio-quality", "0",
            "--embed-metadata",
            "--default-search", "ytsearch",
            "--quiet",
            "--no-warnings",
            "-o", &output_template,
            &format!("ytsearch:{} youtube music", song_query)
        ])
        .status()?;
    
    if !status.success() {
        bail!("yt-dlp command failed with status: {}", status);
    }
    
    Ok(())
}

/// Download a song using spotdl
fn download_with_spotdl(song_query: &str, output_folder: &Path) -> Result<(), Error> {
    // Build spotdl command 
    let status = Command::new("spotdl")
        .current_dir(output_folder)
        .args([
            "--output", "{artist} - {title}.{output-ext}",
            "--output-format", "mp3",
            "--bitrate", "320k",
            "--threads", "1",
            "--format", "mp3",
            "--print-errors",
            "download",
            song_query
        ])
        .status()?;
    
    if !status.success() {
        bail!("spotdl command failed with status: {}", status);
    }
    
    Ok(())
}

/// Parse CSV content into SongInfo structs
fn parse_csv(content: &str) -> Result<Vec<SongInfo>, Error> {
    let mut reader = csv::Reader::from_reader(content.as_bytes());
    let mut songs = Vec::new();
    
    for result in reader.deserialize() {
        let song: SongInfo = result?;
        songs.push(song);
    }
    
    Ok(songs)
}

/// Convert a title to a valid folder name
fn sanitize_filename(filename: &str) -> String {
    // Replace invalid characters with spaces
    let invalid_chars = Regex::new(r#"[<>:"/\\|?*]"#).unwrap();
    let sanitized = invalid_chars.replace_all(filename, " ").to_string();
    
    // Trim leading/trailing whitespace and dots
    let trimmed = sanitized.trim().trim_matches('.');
    
    // Normalize multiple spaces to a single space
    let normalized = Regex::new(r"\s+").unwrap().replace_all(&trimmed, " ").to_string();
    
    // Ensure the filename is not empty
    if normalized.is_empty() {
        return "Unknown_Title".to_string();
    }
    
    normalized
}

/// Generate CSV/JSON output from query-url results
pub fn generate_output_file(
    url_info: &crate::UrlInfo,
    output_path: &Path,
    directory: Option<&Path>,
    format: &str
) -> Result<PathBuf, Error> {
    let mut songs = Vec::new();
    
    // Process videos and their tracklists
    if let Some(videos) = &url_info.videos {
        for (video_title, video_url, tracklist) in videos {
            let folder_name = sanitize_filename(video_title);
            let folder_exists = if let Some(dir) = directory {
                dir.join(&folder_name).exists()
            } else {
                false
            };
            
            info!("Video title: {}", video_title);
            info!("Formatted video title: {}", folder_name);
            info!("Video title exists in directory: {}", folder_exists);
            
            // Process each track in the tracklist
            for track in tracklist {
                // Extract artist and title
                let (artist, title, timestamp) = parse_track(track);
                
                // Only add tracks that have both artist and title
                if !artist.is_empty() && !title.is_empty() {
                    songs.push(SongInfo {
                        video_title: video_title.clone(),
                        video_url: video_url.clone(),
                        song_title: title,
                        artist,
                        timestamp,
                        // Downloaded flag is false when we want to download it
                        // If folder exists, we mark as true (downloaded), if not then false (needs download)
                        downloaded: folder_exists,
                        match_confidence: 0.75, // Default confidence level
                    });
                }
            }
        }
    }
    
    // Create output file
    let output_file = if format == "json" {
        let path = output_path.join("query-url.json");
        let json = serde_json::to_string_pretty(&songs)?;
        fs::write(&path, json)?;
        path
    } else {
        // Default to CSV
        let path = output_path.join("query-url.csv");
        let mut writer = csv::Writer::from_path(&path)?;
        
        for song in &songs {
            writer.serialize(song)?;
        }
        
        writer.flush()?;
        path
    };
    
    // Print summary of what we found
    info!("Generated output file: {:?}", output_file);
    info!("Found {} songs across {} videos", songs.len(), if let Some(videos) = &url_info.videos { videos.len() } else { 0 });
    
    // Count how many songs need to be downloaded
    let download_count = songs.iter().filter(|s| !s.downloaded).count();
    info!("{} songs marked for download", download_count);
    
    Ok(output_file)
}

/// Parse a track string into artist, title, and timestamp
pub fn parse_track(track: &str) -> (String, String, Option<String>) {
    // Check if the track is already in the "Artist - Title" format
    if track.contains(" - ") {
        // Extract timestamp if present at the beginning
        let timestamp_regex = Regex::new(r"^(\d{1,2}:\d{2}(?::\d{2})?)").unwrap();
        let timestamp = timestamp_regex.captures(track).map(|cap| cap[1].to_string());
        
        // Clean up the track string
        let track_without_timestamp = timestamp_regex.replace(track, "").trim().to_string();
        
        // Split by dash to get artist and title
        let parts: Vec<&str> = track_without_timestamp.split(" - ").collect();
        if parts.len() >= 2 {
            let artist_part = parts[0].trim();
            let title_part = parts[1].trim();
            
            // Clean up timestamp prefix and other characters in artist name
            let number_prefix_regex = Regex::new(r"^(\d+(?::\d+)?)\s*").unwrap();
            let clean_artist = number_prefix_regex.replace(artist_part, "").trim().to_string();
            
            // Clean up html entities in both artist and title
            let artist_clean = clean_artist
                .replace("u0026", "&")
                .replace("&amp;", "&")
                .replace("&#39;", "'")
                .trim().to_string();
                
            let title_clean = title_part
                .replace("u0026", "&")
                .replace("&amp;", "&")
                .replace("&#39;", "'")
                .trim().to_string();
            
            // Special case: if artist starts with comma, it's likely part of another field
            let final_artist = if artist_clean.starts_with(',') {
                artist_clean[1..].trim().to_string()
            } else {
                artist_clean
            };
            
            // Final checks for empty fields
            if final_artist.is_empty() || title_clean.is_empty() {
                // Fallback to original parts if cleaning made fields empty
                (parts[0].trim().to_string(), parts[1].trim().to_string(), timestamp)
            } else {
                (final_artist, title_clean, timestamp)
            }
        } else {
            // Fallback if splitting didn't work as expected
            (String::new(), track_without_timestamp, timestamp)
        }
    } else {
        // If no dash, try to identify if this is just an artist or just a title
        // For now, default to treating the whole string as the title
        (String::new(), track.trim().to_string(), None)
    }
}
